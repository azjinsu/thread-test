# 멀티스레드 문제

## 프로그램의 의도

- 여러 개의 thread 에서 1개의 CounterStorate 클래스 (공유 object / 공유 메모리) 를 사용하여 숫자를 증가
	- 단 한번 호출에 1씩 증가하면 멀티스레드 테스트가 힘드므로, repeat 만큼 반복하여 증가
- 각 숫자 (0~19) 의 counter 값이 모두 120000000 로 동일해야 함. (120000000 = 100000 * 100 * 12)
	- 각 숫자별로 / 각 thread 가 100000 번 Increase() 함수 호출
	- 1번 Increase() 함수 호출에 100씩 증가
	- 총 12개의 thread 사용


## 문제점

- 프로그램 실행 후의 각 숫자의 counter 값이 120000000 이 아님


## 목표

- **위의 counter 값 오류 해결**
- ‼️‼️‼️ **프로그램 실행중 CPU 사용률이 100 % 에 근접해야 함** ‼️‼️‼️
	- **THREAD_COUNT** 상수는 실행 환경에 맞도록 설정 (CPU Thread 개수에 맞게 설정)
	- CPU Thread 개수에 맞게 설정되어 있어야 CPU 100% 상황을 발생시킬 수 있음


## 수정 대상

- CounterStorage class



## 수정하지 말아야 할 내용들 or 사용하면 안되는 라이브러리

- Increase() 함수의 for 문을 해체하지 마시오. 즉, ```myCounter[number] += repeat;``` 같은 문장을 사용하지 마시오.
- volatile 속성을 제거하지 마시오
- thread 학습을 위하여 C# 의 Interlocked 클래스 또는 JAVA 의 AtomicInteger 등은 사용하지 마시오
	- 되도록이면 기본적인 동기화 기능만을 사용하여 구현하시오


## 참고 성능

- Intel 10세대 i5 (i5-10500) / 6core 12thread 기준 결과
	- DotNet 6.0 (릴리즈)
		- 문제 원본 버전 : 2740 ms
		- 출제자 답안 버전 : 765 ms
	- JAVA 17 (기본 설정)
		- 문제 원본 버전 : 10597 ms
		- 출제자 답안 버전 : 10172 ms
- 위의 성능 값은 절대적인 기준은 아니며, 사용하고 있는 CPU 종류에 따라 달라질 수 있음
- 중요한 점은 **counter 값 오류**가 발생하지 않으면서, 실행중 **CPU 사용률이 100 %** 에 근접해야 한다는 점임


# 추가 질문 (추후 리뷰 항목)

- volatile 설정 유무에 따른 차이를 설명하시오
